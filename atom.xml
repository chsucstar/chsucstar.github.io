<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-01-08T08:01:50.426Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>chsucstar</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux远程访问第三部分</title>
    <link href="http://example.com/2024/01/08/Linux%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86/"/>
    <id>http://example.com/2024/01/08/Linux%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86/</id>
    <published>2024-01-08T07:46:05.000Z</published>
    <updated>2024-01-08T08:01:50.426Z</updated>
    
    <content type="html"><![CDATA[<h1 id="⬆️什么是-X-Window-？"><a href="#⬆️什么是-X-Window-？" class="headerlink" title="⬆️什么是 X-Window ？"></a>⬆️什么是 X-Window ？</h1><ul><li><strong>X Window System 也简称为X、X11或 X-Window</strong></li><li><strong>一种开放源码、跨平台、客户端-服务器计算机软件系统，可在分布式网络环境中提供GUI</strong></li><li><strong>早期用于 Unix 及变体，现在几乎所有的操作系统都能支持与使用</strong></li><li><strong>GNOME和KDE都是以X系统为基础构成的</strong><ul><li>1984年作为斯坦福大学和麻省理工学院合作的Athena项目的一部分而首次开发</li><li>1987年发布了版本11</li><li>1992年至2004年，XFree86是 X Window 系统最被广泛使用的基础平台</li><li>2004年开始，XFree86 不再使用 GPL 许可证 …</li><li>XOrg 逐渐在开源 Unix 风格系统操作中流行 …</li></ul></li></ul><br><h2 id="➡️X-Window-基本原理"><a href="#➡️X-Window-基本原理" class="headerlink" title="➡️X-Window 基本原理"></a>➡️X-Window 基本原理</h2><p><img src="/images/remote-administration/xwindow.png"></p><p>X-Window 采用的是 客户机-服务器 模式，也就是CS模式，由两部分组成，</p><br><h2 id="➡️X-Window-SSH"><a href="#➡️X-Window-SSH" class="headerlink" title="➡️X-Window + SSH"></a>➡️X-Window + SSH</h2><p><img src="/images/remote-administration/xwindow1.png"></p><p><img src="/images/remote-administration/xwindow2.png"></p><p>远程的保证通讯安全还是通过SSH来构建一个安全通道。</p><h2 id="➡️实验：X-Window-SSH"><a href="#➡️实验：X-Window-SSH" class="headerlink" title="➡️实验：X-Window+SSH"></a>➡️实验：X-Window+SSH</h2><ul><li><strong>下载安装xming</strong></li><li><strong>配置SSH客户端</strong></li></ul><p><img src="/images/remote-administration/xwindow3.png"></p><p>在windows安装有相对应的xming。</p><p>安装完成后配置对应的SSH。</p><p>这时候还要在客户端启动对应的桌面程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># dnf group gnome-desktop</span><br><span class="line"># gedit</span><br></pre></td></tr></table></figure><p>对X11限制转发则需要对SSH转发进行限制，因为X11是通过SSH来进行的转发的。</p><br><h1 id="⬆️Cockpit"><a href="#⬆️Cockpit" class="headerlink" title="⬆️Cockpit"></a>⬆️Cockpit</h1><h2 id="➡️原理与基本功能"><a href="#➡️原理与基本功能" class="headerlink" title="➡️原理与基本功能"></a>➡️原理与基本功能</h2><h3 id="🟦是么是Cockpit？"><a href="#🟦是么是Cockpit？" class="headerlink" title="🟦是么是Cockpit？"></a>🟦是么是Cockpit？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://cockpit-project.org</span><br></pre></td></tr></table></figure><ul><li><strong>开源的基于web的管理工具，可以执行多种管理服务</strong></li><li><strong>可以对主流的Linux发行版本进行集中式管理</strong></li><li><strong>Cockpit的理想：</strong><ul><li>Cockpit是可发现的</li><li>Cockpit直接与系统交互并做出反应</li><li>Cockpit不需要任何配置或基础架构</li><li>Cockpit不是配置管理</li><li>Cockpit只是项目名称</li><li>Cockpit是zero footprint</li><li>… …</li></ul></li></ul><p>除了cockpit以外基于Web网页管理服务器的还有一些其他的。</p><ul><li><p><strong>webmin</strong></p></li><li><p><strong>CentOS Web Panel</strong></p></li><li><p><strong>Ajenti</strong></p></li><li><p><strong>Froxlor</strong></p></li></ul><p>目前cockpit稍微好一些。</p><p>cockpit是交互的服务器的管理页面，是可以发现的（不用读相关的说明），直接与系统交互进行反映不需要数据库，UI直接反映服务器的状态，使用Linux一样的相同的API可以对系统立即作出反映，不需要做配置和一些基础的架构，安装量小，不是配置管理工具，这仅仅是一个项目名称在界面中是不显示logo的，cockpit认为cockpit仅仅是操作系统的UI而不是web工具，磁盘占用小。</p><br><h2 id="➡️Cockpit-部署架构"><a href="#➡️Cockpit-部署架构" class="headerlink" title="➡️Cockpit 部署架构"></a>➡️Cockpit 部署架构</h2><p><img src="/images/remote-administration/cockpit.png"></p><p>模式1：每台Linux都安装有cockpit，管理员通过浏览器分别来进行工作。</p><p>模式2：集中管理，选择任意一台安装有cockpit的服务器，在这上面来安装有仪表盘dashboard的插件，把其他的安装有cockpit的机器，添加注册到仪表盘上，这样就比较方便了，</p><p>模式3：处于安全的考虑，不允许管理员直接与 Linux服务器 来进行直接访问，所以管理员会先进入堡垒机，然后堡垒机代表管理员来访问后面的服务器来管理，这是一种转发的机制，与第二种是不一样的。</p><br><h3 id="🟦Cockpit安装"><a href="#🟦Cockpit安装" class="headerlink" title="🟦Cockpit安装"></a>🟦Cockpit安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># yum -y install cockpit</span><br><span class="line"># systemctl start cockpit.socket</span><br><span class="line"># systemctl enable cockpit.socket</span><br><span class="line"># firewall-cmd --list-service</span><br></pre></td></tr></table></figure><br><h2 id="➡️存储管理"><a href="#➡️存储管理" class="headerlink" title="➡️存储管理"></a>➡️存储管理</h2><h3 id="🟦实验：Cockpit的存储管理"><a href="#🟦实验：Cockpit的存储管理" class="headerlink" title="🟦实验：Cockpit的存储管理"></a>🟦实验：Cockpit的存储管理</h3><ul><li><strong>安装插件：</strong><ul><li>cockpit-storaged</li></ul></li><li><strong>基本概念：</strong><ul><li>物理存储介质</li><li>分区</li><li>LVM组件：<ul><li>物理卷（Physical Volume , PV）</li><li>卷组 （Volume Group，VG）</li><li>逻辑卷 （Logical Volume，LV）</li></ul></li></ul></li></ul><p><img src="/images/remote-administration/cockpit1.png"></p><p>进行存储的管理一定要谨慎，因为一旦误操作成本是很高的。</p><p>实验环境中添加了一块 30GB 的磁盘，准备整个做成PV然后做成VG，把VG划到一个LV里面，做成一个文件系统，同时monut到某个目录中。</p><p>如果cockpit中没有存储管理的功能，那么就需要安装插件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># rpm -qa | grep cock</span><br><span class="line"># dnf list | grep cockpit</span><br><span class="line"></span><br><span class="line"># dnf -y install cockpit-storage</span><br></pre></td></tr></table></figure><p>这样就安装完插件了，刷新页面就可以看到 存储 模块了。</p><p>在 存储 界面中，选择 组卷 去新添加一个卷组， 然后选择新添加的硬盘，这就相当于是创建VG了。</p><p>然后 创建逻辑卷 选择30G全部，然后创建文件系统格式化，自定义mount点，选择引导时自动挂载。</p><br><h2 id="➡️仪表盘与虚拟化"><a href="#➡️仪表盘与虚拟化" class="headerlink" title="➡️仪表盘与虚拟化"></a>➡️仪表盘与虚拟化</h2><h3 id="🟦实验：Cockpit的集中管理"><a href="#🟦实验：Cockpit的集中管理" class="headerlink" title="🟦实验：Cockpit的集中管理"></a>🟦实验：Cockpit的集中管理</h3><ul><li><strong>安装插件：</strong><ul><li>cockpit-dashboard</li></ul></li><li><strong>功能：</strong><ul><li>整体视图</li><li>灵活切换</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># dnf -y install cockpit-dashboard</span><br></pre></td></tr></table></figure><p>安装完dashboard后需要在网页上先注销登陆，然后重新登陆，这样就能看到仪表板了。</p><br><h3 id="🟦实验：Cockpit的KVM虚拟机管理"><a href="#🟦实验：Cockpit的KVM虚拟机管理" class="headerlink" title="🟦实验：Cockpit的KVM虚拟机管理"></a>🟦实验：Cockpit的KVM虚拟机管理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># dnf -y install cockpit-machines</span><br></pre></td></tr></table></figure><ul><li><strong>安装插件 cockpit-machines</strong></li><li><strong>功能：</strong><ul><li>管理存储池</li><li>管理网路</li><li>管理虚拟机<ul><li>创建虚拟机</li><li>修改配置</li><li>删除虚拟机</li><li>电源管理</li><li>控制台访问<ul><li>VNC</li><li>Virt-viewer</li><li>串口</li></ul></li></ul></li></ul></li></ul><p>这个插件用于管理KVM虚拟化的，KVM是内核虚拟机的一个缩写。</p><p>使用cockpit后可以使用web的方式来管理虚拟机了。</p><p>控制台提供有三种，第一种直接用VNC，还有是下载插件还有支持串口的连接。</p><br><h2 id="➡️扩展知识：实现双因素认证1"><a href="#➡️扩展知识：实现双因素认证1" class="headerlink" title="➡️扩展知识：实现双因素认证1"></a>➡️扩展知识：实现双因素认证1</h2><h3 id="🟦概述"><a href="#🟦概述" class="headerlink" title="🟦概述"></a>🟦概述</h3><ul><li><strong>身份验证方法</strong></li><li><strong>多因素验证</strong></li><li><strong>Cockpit + Google Authenticator 双因素身份验证</strong><ul><li>原理</li><li>移动器端安装配置</li><li>SELinux 相关的问题</li></ul></li><li><strong>误区</strong><ul><li>必须禁用SELinux</li><li>因为要与Google的认证服务相连，所以服务器需要连接互联网。</li></ul></li></ul><br><h3 id="🟦身份验证方法"><a href="#🟦身份验证方法" class="headerlink" title="🟦身份验证方法"></a>🟦身份验证方法</h3><ul><li><p><strong>你知道什么？</strong> 密码</p><ul><li>用户密码</li><li>OTP        One-Time Password , 一次性密码<ul><li>HOTP        HMAC-based One-Time Password , 基于 HMAC</li><li>HOTP        Time-based One-Time Password , 基于时间戳算法的一次性密码</li></ul></li></ul></li><li><p><strong>你有什么？</strong></p><ul><li>证书</li></ul></li><li><p><strong>你是谁？</strong></p><ul><li>生物特征 （指纹、人脸）</li></ul></li><li><p><strong>你在哪里？</strong>逻辑地址</p><ul><li>IP地址</li><li>MAC地址</li><li>电话号码<ul><li>有可能会被修改，MAC地址也是有工具来进行修改的。</li><li>逻辑地址通常是用做辅助的验证手段</li></ul></li></ul></li></ul><p>身份验证就是要解决你是谁这个问题，有很多种验证身份的方法。</p><br><h3 id="🟦多因素验证（MFA、Multi-factor-authentication）"><a href="#🟦多因素验证（MFA、Multi-factor-authentication）" class="headerlink" title="🟦多因素验证（MFA、Multi-factor authentication）"></a>🟦多因素验证（MFA、Multi-factor authentication）</h3><ul><li><strong>用户要通过两种或两种以上的认证机制之后，才能得到授权</strong></li><li><strong>双因素认证（2FA，Two-factor authentication）是多因素验证中的特例</strong></li></ul><p>这是一种计算机的访问方法，用户通过两种或者两种以上的认证方式，才能获取资源。</p><p><img src="/images/remote-administration/cockpit2.png"></p><br><h3 id="🟦Cockpit身份验证"><a href="#🟦Cockpit身份验证" class="headerlink" title="🟦Cockpit身份验证"></a>🟦Cockpit身份验证</h3><p><img src="/images/remote-administration/cockpit3.png"></p><p>cockpit的登陆过程：左边的用户通过浏览器发起连接服务器的请求，cockpit实际上不做身份上的验证，默认的情况下会转发到 PAM（可插入认证模块），这可以动态引入模块插件而不用去重启系统。</p><p>PAM是通过配置文件来设置的默认是在右上目录的具体你的服务软件名上。这样PAM会调用一些库文件等来操作，对用户来验证。</p><br><h3 id="🟦Cockpit-Google-Authenticator-双因素身份验证"><a href="#🟦Cockpit-Google-Authenticator-双因素身份验证" class="headerlink" title="🟦Cockpit + Google Authenticator 双因素身份验证"></a>🟦Cockpit + Google Authenticator 双因素身份验证</h3><ul><li><p><strong>基于时间与哈希的一次性密码算法的两种验证软件令牌</strong></p></li><li><p><strong>最初应用与Google的自有的认证服务</strong></p></li><li><p><strong>所使用的算法已列于 PFC 6238 和 RFC 4226</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/goole/goole-authenticator-libpam/</span><br></pre></td></tr></table></figure></li></ul><p>这就需要安装为Linux PAM 所写的Google验证器的插件（这是一种基于时间与哈希的一次性密码算法的两种验证软件令牌），最初用于google的服务，后来就可以为第三方软件生成动态口令也就是PAM插件。</p><p>双因素验证的工作原理：用户在智能手机上安装google的验证APP，登陆到服务器上，再服务器上执行命令，该命令会在服务器上生成验证器所需要的秘钥文件，同时这个命令也会生成一个二维-码这就包含了一些初始化的信息。用户通过APP扫描二维码，当然让服务器显示二维码需要root用户安装一个rpm包，这样就能生成一些秘钥的文件的初始化信息，用户的手机和服务器的插件就共享了相同的初始化信息了。当然若不想扫描二维码就需要手工输入字符串就可以了。</p><p>不管是在服务器端生成秘钥文件，生成二维码；客户端扫描二维码或者是手工输入相关的信息，这个过程中服务器插件和客户端的APP都是不需要联网的，都是脱机来运行的。</p><p>为了避免各种意外，用户在服务器上执行的命令的时候，还会生成一个紧急的密码，这是为了避免出现意外而使用的一次性密码。</p><p>当用户的APP和服务器使用的相同的信息，同时时间上的差异也不大，那么就会生成一个密码，那在用户登陆之后，界面会提示输入动态密码，用户输入后，服务器通过插件来验证动态密码的正确。</p><br><h2 id="➡️扩展知识：实现双因素认证2"><a href="#➡️扩展知识：实现双因素认证2" class="headerlink" title="➡️扩展知识：实现双因素认证2"></a>➡️扩展知识：实现双因素认证2</h2><h3 id="🟦实验：Cockpit-Google-Authenticator双因素身份验证"><a href="#🟦实验：Cockpit-Google-Authenticator双因素身份验证" class="headerlink" title="🟦实验：Cockpit + Google Authenticator双因素身份验证"></a>🟦实验：Cockpit + Google Authenticator双因素身份验证</h3><ul><li><strong>系统配置</strong><ul><li>安全服务器端组件</li><li>修改Cockpit的PAM配置</li><li>重新启动cockpit</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># dnf -y install grencode epel-release</span><br><span class="line"># dnf -y install google-authenticator</span><br><span class="line"></span><br><span class="line"># vi /etc/pam.d/cockpit</span><br><span class="line">  添加</span><br><span class="line"> # auth requird pam_google_authenticator.so</span><br><span class="line"> auth requird pam_google_authenticator.so nullok secret=$&#123;HOME&#125;/.cockpit/.google_authenticator</span><br><span class="line"> </span><br><span class="line"># systemctl restart cockpit.service</span><br><span class="line"># systemctl restart cockpit.socket</span><br></pre></td></tr></table></figure><p>nullok 的意思的如果用户的家目录没有后面的文件，那就不做双因素认证。</p><ul><li><p><strong>用户使用</strong></p><ul><li><p>安装移动端服务器</p><p><img src="/images/remote-administration/cockpit4.png"></p></li><li><p>登陆服务器，创建秘钥文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># cd ~</span><br><span class="line"># mkdir .cockpit</span><br><span class="line"># goole-authenticator --secret=.cockpit/.goole_authenticator</span><br><span class="line"> Do you want authentication tokens to be time-based (y/n) y</span><br></pre></td></tr></table></figure><p>这同时会生成5个紧急的密码，密码5个密码都只能使用1次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chcon -R -v -t cockpit_tmp_t .cockpit</span><br></pre></td></tr></table></figure><p>配置selinux上下文。</p></li><li><p>客户重新登陆</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;⬆️什么是-X-Window-？&quot;&gt;&lt;a href=&quot;#⬆️什么是-X-Window-？&quot; class=&quot;headerlink&quot; title=&quot;⬆️什么是 X-Window ？&quot;&gt;&lt;/a&gt;⬆️什么是 X-Window ？&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;</summary>
      
    
    
    
    <category term="Linux服务配置" scheme="http://example.com/categories/Linux%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE/"/>
    
    
    <category term="X-Window" scheme="http://example.com/tags/X-Window/"/>
    
    <category term="cockpit" scheme="http://example.com/tags/cockpit/"/>
    
  </entry>
  
  <entry>
    <title>Linux远程访问第二部分</title>
    <link href="http://example.com/2024/01/07/Linux%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/"/>
    <id>http://example.com/2024/01/07/Linux%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/</id>
    <published>2024-01-07T04:27:44.000Z</published>
    <updated>2024-01-08T07:44:25.681Z</updated>
    
    <content type="html"><![CDATA[<h1 id="⬆️VNC概念与原理"><a href="#⬆️VNC概念与原理" class="headerlink" title="⬆️VNC概念与原理"></a>⬆️VNC概念与原理</h1><p>Linux 大多数情况下都是远程进行管理的，当在管理的过程中很少会用到图形界面，多数情况下用到的是 ssh 连接服务器。</p><p>有的时候使用图形界面会方便一些，比如说甲骨文的数据库的安装。</p><br><h2 id="➡️什么是-VNC"><a href="#➡️什么是-VNC" class="headerlink" title="➡️什么是 VNC"></a>➡️什么是 VNC</h2><p>VNC 允许我们开启一个远程的会话来连接，这样就能远程访问图形界面了。</p><ul><li><strong>Virtual Network Console</strong></li><li><strong>VNC 是一个自由开源软件</strong></li><li><strong>目的：让用户可以远程访问服务器的桌面环境</strong></li><li><strong>服务器包括：</strong><ul><li>Linux、Unix、FreeBSD</li><li>Windows</li><li>…</li></ul></li><li><strong>很多平台均有 VNC viewer客户端</strong></li></ul><br><h2 id="➡️VNC-基本原理"><a href="#➡️VNC-基本原理" class="headerlink" title="➡️VNC 基本原理"></a>➡️VNC 基本原理</h2><ul><li><strong>两部分组成：</strong><ul><li>服务端的应用程序   vncserver</li><li>客户端的应用程序   vncviewer</li></ul></li><li><strong>工作原理</strong><ul><li>在服务器端启动 VNC Server</li><li>VNC客户端通过浏览器或 VNC Viewer 连接至 VNC Server</li><li>VNC Server 传送对话窗口至客户端，要求输入密码，以及存取的 VNC Server 显示设备。</li><li>在客户端输入联机密码后，VNC Server 验证客户端是否具有存储权限。</li><li>若是客户端通过 VNC Server 的验证，客户端即要求 VNC Server 显示桌面环境 VNC Server 通过 X Protocol 要求 X Server 将画面显示控制权交由 VNC Server 负责。</li><li>VNC Server 将来由 X Server 的桌面环境利用 VNC 通信协议送至客户端，并且允许客户端控制 VNC Server 的桌面环境及输入装置。</li></ul></li></ul><p><img src="/images/remote-administration/vnc.png"></p><br><h2 id="➡️新的VNC-服务器安装"><a href="#➡️新的VNC-服务器安装" class="headerlink" title="➡️新的VNC 服务器安装"></a>➡️新的VNC 服务器安装</h2><h3 id="🟦新版-Linux上安装-VNC-服务器"><a href="#🟦新版-Linux上安装-VNC-服务器" class="headerlink" title="🟦新版-Linux上安装 VNC 服务器"></a>🟦新版-Linux上安装 VNC 服务器</h3><p>2021年 <strong>centos8</strong> 将 <strong>tigerVNC</strong> 进行了升级，把 <strong>1.9</strong> 升级到了 <strong>1.10.1</strong>，这在管理上有改动。</p><p>原来是属于高级配置的管理功能，（把 VNCserver 作为服务自动启动、多用户同时使用）简化了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># dnf -y install tigervnc-server</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># rpm -qi tigervnc-server</span><br><span class="line"># rpm -qc tigervnc-server</span><br><span class="line"># rpm -ql tigervnc-server | grep bin</span><br></pre></td></tr></table></figure><br><h3 id="🟦新版-考察安装结果"><a href="#🟦新版-考察安装结果" class="headerlink" title="🟦新版-考察安装结果"></a>🟦新版-考察安装结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># vncserver --help</span><br><span class="line">vncserver has been replaced by a systemd unit.</span><br><span class="line">Please read /usr/share/doc/tigervnc/HOWTO.md for more information.</span><br></pre></td></tr></table></figure><p>这里说可以通过 <code>systemctl</code> 来控制，在早期版本可以很简单的去运行 vncserver，而要将其做成服务，做成 unit 还是需要好几个配置的，新的版本做出了简化。</p><br><h3 id="🟦新版-配置VNC服务器"><a href="#🟦新版-配置VNC服务器" class="headerlink" title="🟦新版-配置VNC服务器"></a>🟦新版-配置VNC服务器</h3><p><strong>1.添加用户映射</strong></p><p>用户映射的意思：在 VNC 里面允许有多个桌面，每个桌面有个桌面编号，下面是1号桌面与 root 做管理，2号桌面则与 tom 做关联。</p><blockquote style="border-left: 5px solid #6CA2F9; background-color: #ECF3FE; padding: 10px;"><div style="color: #24687D; font-weight: bold;height: 20px;height:25px;">🔵 注意：</div>     <p style=" text-indent: 2em;">vnc用自己的密码体系</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/tigervnc/vncserver.users</span><br><span class="line">:1=root</span><br><span class="line">:2=tom</span><br></pre></td></tr></table></figure><blockquote style="border-left: 5px solid #f0ab00; background-color: #fdf7e7; padding: 10px;"><div style="color: #7d643f; font-weight: bold;height: 20px;height:25px;">🟡 重要：</div>     <p style=" text-indent: 2em;">这里面的账户需要你本地Linux系统中有一样命名账户    。</p>    <p style=" text-indent: 2em;">这里面的账户密码是自己的密码，和操作系统的密码是不一样的。</p></blockquote><p><strong>监听端口：</strong><code>590+桌面号</code></p><p>做了关联之后，<code>客户端 IP:590+桌面号</code> 来添加。</p><p>这样就做到了以不同的桌面监听不同的端口号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># netstat -anp | grep vnc | grep ^top</span><br><span class="line">ProtoLocal AddressForeign Address StatePID/Program</span><br><span class="line">tcp     0.0.0.0:5901    0.0.0.0:*           LISTEN      34189/Xvnc</span><br><span class="line">tcp     0.0.0.0:5902    0.0.0.0:*           LISTEN      34143/Xvnc</span><br><span class="line">tcp6    :::5901         :::*                LISTEN      34189/Xvnc</span><br><span class="line">tcp6    :::5902         :::*                LISTEN      35143/Xvnc</span><br></pre></td></tr></table></figure><p><strong>2.配置Xvnc的选项</strong></p><ul><li><p><strong>配置文件应用次序：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/etc/tigervnc/vncserver-config-default</span><br><span class="line">            ↓</span><br><span class="line">$HOME/.vnc/config</span><br><span class="line">            ↓</span><br><span class="line">/etc/tigervnc/vncserver-config-madatory</span><br><span class="line">从优先级来说是反着来的</span><br></pre></td></tr></table></figure></li><li><p><strong>最简单的配置：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># vi /etc/tigervnc/vncserver-config-default</span><br><span class="line">  session=gnome</span><br><span class="line">  </span><br><span class="line"># man vncserver</span><br><span class="line"># man xvnc</span><br></pre></td></tr></table></figure><p>这就是说，用户登陆后使用的是gnome的桌面。</p></li></ul><p><strong>3.设置VNC密码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># id -un</span><br><span class="line">  root</span><br><span class="line"></span><br><span class="line"># vncpasswd</span><br><span class="line">  Password: 输入密码</span><br><span class="line">  Verify: 再次输入密码</span><br><span class="line">  Would you like lo enLer a view-only password (y/n)? n</span><br><span class="line">  A view-only password is not used</span><br></pre></td></tr></table></figure><p>VNC 设置用户的密码，这需要在当前登陆用户来进行.</p><p>如：设置 VNC 中 root 的密码，那么当前操作系统的用户就是 root。密码会保存在家目录一个名为 vnc 的隐藏文件夹当中。</p><p><strong>4.启动Tigervnc服务器</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># systemctl start vncserver@:1.serice</span><br><span class="line"># systemctl enable vncserver@:1.serice</span><br><span class="line"></span><br><span class="line"># systemctl start vncserver@:2.serice</span><br><span class="line"># systemctl enable vncserver@:2.serice</span><br></pre></td></tr></table></figure><p>这启动了第一个桌面，第二个桌面。</p><p><strong>5.配置防火墙</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># firewall-cmd --add-service=vnc-server --permanent</span><br><span class="line"># firewall-cmd --reload</span><br><span class="line"># firewall-cmd --info-service=vnc-server</span><br><span class="line">  vnc-server</span><br><span class="line">     ports: 5900-5903/tcp</span><br><span class="line">     protocols:</span><br><span class="line">  ... 略 ...</span><br></pre></td></tr></table></figure><br><h2 id="➡️旧版VNC-服务器安装"><a href="#➡️旧版VNC-服务器安装" class="headerlink" title="➡️旧版VNC 服务器安装"></a>➡️旧版VNC 服务器安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># yum -y install tigervnc-server</span><br><span class="line"># rpm -qi tigervnc-server</span><br><span class="line"># rpm -qc tigervnc-server</span><br><span class="line">  /etc/sysconfig/vncservers</span><br></pre></td></tr></table></figure><br><h2 id="➡️VNC-服务器最简单的配置"><a href="#➡️VNC-服务器最简单的配置" class="headerlink" title="➡️VNC 服务器最简单的配置"></a>➡️VNC 服务器最简单的配置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># vncserver</span><br><span class="line"># vncserver -list</span><br><span class="line"></span><br><span class="line"># ps aux | grep vnc</span><br><span class="line"># netstat -anp | grep vnc</span><br></pre></td></tr></table></figure><p>第一次执行vnc的时候，不需要一些额外的参数。</p><br><h2 id="➡️VNC客户端"><a href="#➡️VNC客户端" class="headerlink" title="➡️VNC客户端"></a>➡️VNC客户端</h2><h3 id="🟦Windows上的VNC客户机"><a href="#🟦Windows上的VNC客户机" class="headerlink" title="🟦Windows上的VNC客户机"></a>🟦Windows上的VNC客户机</h3><ul><li><p><strong>常见的客户端</strong></p><ul><li>Realvnc viewer</li><li>Tightvnc viewer</li></ul></li><li><p><strong>下载地址</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.realvnc.com/en/connect/download/vnc/</span><br></pre></td></tr></table></figure></li></ul><br><h3 id="🟦VNC链接测试-新版本客户端"><a href="#🟦VNC链接测试-新版本客户端" class="headerlink" title="🟦VNC链接测试-新版本客户端"></a>🟦VNC链接测试-新版本客户端</h3><p><strong>服务器标识</strong></p><ul><li><code>IP地址:桌面编号</code></li><li><code>IP地址:网络端口号</code></li></ul><br><h2 id="➡️作为服务自动启动"><a href="#➡️作为服务自动启动" class="headerlink" title="➡️作为服务自动启动"></a>➡️作为服务自动启动</h2><p>VNC的高级设置：VNC Server作为服务自动启动、多用户同时访问、通过SSH加密流量。</p><p>如果是经常去访问 VNC 可以把 VNC Server自动其启动，这样即使是服务器自动启动了，那么也能很快的连接上去。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># rpm -ql tigervnc-server</span><br><span class="line">  ... ...</span><br><span class="line">  /usr/lib/systemd/system/vncserver@.service</span><br><span class="line">  ... ...</span><br><span class="line"># cp /usr/lib/systemd/system/vncserver@.service \</span><br><span class="line">     /etc/systemd/system/vncserver@:1.service</span><br><span class="line"># vi /etc/systemd/system/vncserver@\:1.service</span><br><span class="line">  ... ...</span><br><span class="line">  #ExecStart=/usr/bin/vncserver_wrapper &lt;USER&gt; %i</span><br><span class="line">  ExecStart=/usr/bin/vncserver_wrapper root %i</span><br><span class="line"></span><br><span class="line"># systemctl deamon-reload</span><br><span class="line"># systemctl start vncserver@\:1.service</span><br><span class="line"># systemctl enable vucserver@:1.service</span><br></pre></td></tr></table></figure><br><h2 id="➡️多用户同时访问"><a href="#➡️多用户同时访问" class="headerlink" title="➡️多用户同时访问"></a>➡️多用户同时访问</h2><p><strong>Alice使用桌面1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># cp /usr/lib/systemd/system.cnvserver@.service \</span><br><span class="line">  /etc/systemd/system/vncserver-alice@.service</span><br><span class="line"># vi /etc/systemd/system/vncserveer-alice@.service</span><br><span class="line">  ... ...</span><br><span class="line">  ExecStart=/usr/bin/vncserver_wrapper alice %i</span><br><span class="line">  ... ...</span><br><span class="line"># systemctl start vncserver-alice@:1.service</span><br><span class="line"># systemctl eanble vncserver-alice@:1.service</span><br></pre></td></tr></table></figure><p><strong>Bob使用桌面2</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># cp /usr/lib/systemd/system.cnvserver@.service \</span><br><span class="line">  /etc/systemd/system/vncserver-bob@.service</span><br><span class="line"># vi /etc/systemd/system/vncserveer-bob@.service</span><br><span class="line">  ... ...</span><br><span class="line">  ExecStart=/usr/bin/vncserver_wrapper alice %i</span><br><span class="line">  ... ...</span><br><span class="line"># systemctl start vncserver-bob@:2.service</span><br><span class="line"># systemctl eanble vncserver-bob@:2.service</span><br></pre></td></tr></table></figure><p>同时访问有两种模式，第一种是多人访问同一个桌面编号的情况，这种情况很简单。</p><p>或者每个人访问不同的桌面，这就需要配置不同的网络端口。</p><br><h2 id="➡️通过SSH加密流量"><a href="#➡️通过SSH加密流量" class="headerlink" title="➡️通过SSH加密流量"></a>➡️通过SSH加密流量</h2><h3 id="🟦VNC传输的安全性"><a href="#🟦VNC传输的安全性" class="headerlink" title="🟦VNC传输的安全性"></a>🟦VNC传输的安全性</h3><p><img src="/images/remote-administration/vnc1.png"></p><p>VNC 客户端 与 tigerVNC 之间的网络流量是不加密的，也就是通过明文来传递，这就有安全问题，因为黑客有可能截获还原用户操作的过程。</p><p>有一些 VNC 的服务器，支 持VNC 的加密。</p><br><h3 id="🟦VNC-SSH隧道"><a href="#🟦VNC-SSH隧道" class="headerlink" title="🟦VNC+SSH隧道"></a>🟦VNC+SSH隧道</h3><p><img src="/images/remote-administration/vnc2.png"></p><p>对于 tigerVNC 来说，可以使用SSH来结合一下。</p><p>先通过 SSH 来构建一条安全隧道，然后在其中去传递 VNC 的信息，这是 tigerVNC 的标准做法。</p><p><strong>工作原理：</strong>右边是SSH的服务器，比如说是o penssh-server ,先会和左边的客户端 putty 建立起连接构建一个安全通道，在左边的windows主机上，假如putty主机的ID是3712，通过终端上的命令 <code>netstat -ano | find "5901"</code> 可以看到查看3712进程在监听5901的端口。左边 VNC 客户机的进程是10092,它的访问地址是 localhost:1 也就是访问本地一号桌面，也就是访问5901端口，5901又是putty在监听。</p><p>这些流量会通过安全隧道发送到右边的服务器端，这里面服务器的SSH的端口是5630，会把收到的请求转发给本地监听5901的进程，这个进程是1389。这样5630建立起来会话，VNC 的请求会通过隧道转发给 VNCserver 收到。</p><p>这种VNC+SSH的工作原理，是SSH的客户端和SSH的服务器之间先建立起安全的隧道，VNC客户端的流量首先会传递给本地是SSH客户机，然后转发SSH服务器，随后给 VNCserver。</p><p>这个方案的关键点就是SSH客户机。</p><br><h3 id="🟦配置"><a href="#🟦配置" class="headerlink" title="🟦配置"></a>🟦配置</h3><p>启动SSH的客户端软件指定SSH隧道，在SSH中输入监听的端口 <code>5901</code>，然后设置转发的远程的 <code>192.168.10.10:5901</code> 。</p><p>打开 VNC 的客户端，这时候输入的是 <code>localhost:1</code> 这实际上是SSH客户端监听相关进程的端口。</p><br><h1 id="⬆️远程桌面XRDP"><a href="#⬆️远程桌面XRDP" class="headerlink" title="⬆️远程桌面XRDP"></a>⬆️远程桌面XRDP</h1><h2 id="➡️开源RDP（远程桌面协议）服务器-xrdp"><a href="#➡️开源RDP（远程桌面协议）服务器-xrdp" class="headerlink" title="➡️开源RDP（远程桌面协议）服务器 xrdp"></a>➡️开源RDP（远程桌面协议）服务器 xrdp</h2><p><strong>xrdp提供RDP服务，支持：</strong></p><ul><li>双向剪贴板传输</li><li>音频、驱动器重定向</li><li>TLS加密（默认启用）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># cat /etc/system-release</span><br><span class="line">  CentOS Linux release 8.1.1911 (Core)</span><br><span class="line"># dnf -y install epel-release</span><br><span class="line"># dnf -y install xrdp</span><br><span class="line"></span><br><span class="line"># systemctl start xrdp</span><br><span class="line"># systemctl enable xrdp</span><br><span class="line"># systemctl status xrdp</span><br><span class="line"></span><br><span class="line"># firewall-cmd --add-service=rdp --permanent</span><br><span class="line"># firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>xrdp 采用的是标准的 rdp协议，所以说有多种客户端软件，这样在许多设备都能进行使用。</p><p>可以把远程的文件系统 <code>mount</code> 到本地，默认情况下 rdp 使用的是 <code>TLS加密</code>，这点和 VNC 不同，在 CentOS8 中 xrdp 的安装和使用都比较简单。</p><p>dnf 比 yum 的后端依赖解释器更高一些。</p><blockquote style="border-left: 5px solid #6CA2F9; background-color: #ECF3FE; padding: 10px;"><div style="color: #24687D; font-weight: bold;height: 20px;height:25px;">🔵 注意：</div>     <p style=" text-indent: 2em;">如果是在虚拟机vmware上进行实验，可以安装一个驱动，这样性能会好一些</p>    <p style=" text-indent: 2em;"><code># dnf list | grep vmware</code></p>    <p style=" text-indent: 2em;"><code># dnf -y install xorg-x11-drv-vmware</code></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;⬆️VNC概念与原理&quot;&gt;&lt;a href=&quot;#⬆️VNC概念与原理&quot; class=&quot;headerlink&quot; title=&quot;⬆️VNC概念与原理&quot;&gt;&lt;/a&gt;⬆️VNC概念与原理&lt;/h1&gt;&lt;p&gt;Linux 大多数情况下都是远程进行管理的，当在管理的过程中很少会用到图形界</summary>
      
    
    
    
    <category term="Linux服务配置" scheme="http://example.com/categories/Linux%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE/"/>
    
    
    <category term="VNC" scheme="http://example.com/tags/VNC/"/>
    
    <category term="XRDP" scheme="http://example.com/tags/XRDP/"/>
    
  </entry>
  
  <entry>
    <title>Linux远程访问第一部分</title>
    <link href="http://example.com/2024/01/04/Linux%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/"/>
    <id>http://example.com/2024/01/04/Linux%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/</id>
    <published>2024-01-04T04:03:53.000Z</published>
    <updated>2024-01-06T04:13:12.429Z</updated>
    
    <content type="html"><![CDATA[<p>远程访问会用到 <code>ssh</code> 、<code>telnet</code> ，对于 telent 来说传输的数据是不加密的，密码是通过纯文本的形式来传递的，可以使用包获取工具来进行抓包解析。</p><br><h1 id="⬆️Telnet"><a href="#⬆️Telnet" class="headerlink" title="⬆️Telnet"></a>⬆️Telnet</h1><p>由于 telent 是以明文的方式进行数据的传递，所以对比 ssh 来说是不安全的，但是有的时候也会有用到 telnet 的情况。</p><p>早期由于计算机资源只在军队和高校上使用，所以并没有考虑到信息加密，所以早期的计算机使用明文来进行通讯，这也就是 Telnet 能被使用原因。</p><br><h2 id="➡️安装-telnet"><a href="#➡️安装-telnet" class="headerlink" title="➡️安装 telnet"></a>➡️安装 telnet</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum -y install telnet-server telnet</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># firewall-cmd -add-service=telnet</span></span><br><span class="line"><span class="comment"># firewall-cmd -add-service=telent --permanent</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># systemctl start telnet.socket</span></span><br></pre></td></tr></table></figure><p>telnet 使用的端口是 <code>23</code> ，采用的是 C&#x2F;S 架构的方式，同时禁止管理员直接登陆。</p><h2 id="➡️关于-telnet"><a href="#➡️关于-telnet" class="headerlink" title="➡️关于 telnet"></a>➡️关于 telnet</h2><ul><li><p><strong>telnet 的数据流</strong></p><p>① 本地信息通过操作系统传入客户机</p><p>② 客户机程序处理信息后返回操作洗头膏，并通过操作系统经过网络传入目标远程机器</p><p>③ 远程的操作系统获得程序于是传给服务器程序，通过服务器程序再次处理返回操作系统上的伪终端</p><p>④ 操作系统程序将数据传送到用户正在运行的应用程序</p></li></ul><p><img src="/images/remote-administration/telnet.png"></p><ul><li><strong>telnet 使用另一个局限是开销大的原因</strong><ul><li>①每次输入输出计算机切换环境会多次切换</li><li>② telnet 是逐字节传输数据。</li></ul></li></ul><br><h1 id="⬆️SSH（Secure-shell）协议"><a href="#⬆️SSH（Secure-shell）协议" class="headerlink" title="⬆️SSH（Secure shell）协议"></a>⬆️SSH（Secure shell）协议</h1><p>ssh 是建立在应用层上的安全协议，最初是在 Unix 上的用来代替 telnet 等类型的程序。</p><p><img src="/images/remote-administration/image-20230703111448428.png"></p><ul><li><strong>windows 上的关于 ssh 连接的软件</strong><ul><li>Putty</li><li>OpenSSH</li><li>Termius</li><li>SecureCRT</li><li>MobaXterm</li></ul></li></ul><br><h2 id="➡️SSH-linux-客户端"><a href="#➡️SSH-linux-客户端" class="headerlink" title="➡️SSH linux 客户端"></a>➡️SSH linux 客户端</h2><p>多数发新版自带有 ssh  软件，基本都是 <code>OpenSSH-client</code></p><br><h3 id="🟦OpenSSH-client"><a href="#🟦OpenSSH-client" class="headerlink" title="🟦OpenSSH-client"></a>🟦OpenSSH-client</h3><ul><li><strong>关于 openssh-client 的配置</strong><ul><li><strong>全局配置</strong><ul><li>&#x2F;etc&#x2F;ssh&#x2F;ssh_config</li><li>&#x2F;etc&#x2F;ssh&#x2F;ssh_comfig&#x2F;*.conf</li></ul></li><li><strong>个人配置</strong><ul><li>~&#x2F;.ssh&#x2F;config</li></ul></li></ul></li><li><strong>命令：</strong><ul><li>ssh：OpenSSH SSH client (remote login program)</li><li>scp： Secure copy (remove file copy program)</li><li>sftp：Secure file transfer program</li></ul></li></ul><blockquote style="border-left: 5px solid #6CA2F9; background-color: #ECF3FE; padding: 10px;"><div style="color: #24687D; font-weight: bold;height: 20px;height:25px;">🔵 注意：</div>     <p style=" text-indent: 2em;">/etc/ssh/ssh_config 大部分是注释，默认有效的一行内容是加载一个目录。</p>    <p style=" text-indent: 2em;">~/.ssh/config 在home目录中有一个隐藏的文件夹，这个文件夹中有一个文件，包含的内容是 主机 + 秘钥</p></blockquote><br><h3 id="🟦SSH-的使用"><a href="#🟦SSH-的使用" class="headerlink" title="🟦SSH 的使用"></a>🟦SSH 的使用</h3><p>使用ssh连接默认使用的是root用户，可以加上参数 <code>ssh -l</code> 指定用户；或者是 <code>ssh 用户名@主机名</code> ，在这后面可以加上命令，这样会使得连接后执行命令随后退出ssh登陆。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ssh 192.168.1.232</span><br><span class="line"># ssh -l  tom 192.168.1.232  或者   ssh tom@192.168.1.232</span><br><span class="line"># ssh tom@192.168.1.232 ip a</span><br></pre></td></tr></table></figure><p><strong>scp的使用：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp anaconda.cfg root@192.168.1.232:/tmp/</span><br></pre></td></tr></table></figure><p><strong>sftp的使用：</strong></p><p>sftp与scp的命令类似</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># sftp 192.168.1.232</span><br><span class="line">sftp&gt; mget * 可以同时下过个文件到本地</span><br></pre></td></tr></table></figure><br><h2 id="➡️拒绝-root-用户登陆"><a href="#➡️拒绝-root-用户登陆" class="headerlink" title="➡️拒绝 root 用户登陆"></a>➡️拒绝 root 用户登陆</h2><h3 id="🟦OpenSSH-服务器配置文件"><a href="#🟦OpenSSH-服务器配置文件" class="headerlink" title="🟦OpenSSH 服务器配置文件"></a>🟦OpenSSH 服务器配置文件</h3><p>由于 ssh 是 Linux 最常用的远程访问协议，所以很多黑客会去查找漏洞。</p><p>下面是 <code>/etc/ssh</code></p><ul><li><strong>监听端口：<code>port 22</code></strong></li><li><strong>监听地址：<code>ListenAddress 0.0.0.0</code></strong></li><li><strong>允许 root 用户登陆：<code>PermitRootLogin yes</code></strong></li><li><strong>禁用 DNS 反向解析：<code>UseDNS no</code></strong></li></ul><table><thead><tr><th>配置文件</th><th>描述</th></tr></thead><tbody><tr><td>moduli</td><td>比较大的文本文件，是加密算法所使用的素数和随机秘钥生成器的文件</td></tr><tr><td>ssh_config</td><td>这是客户端的配置</td></tr><tr><td>ssh_config.d</td><td>是ssh服务器端的配置</td></tr><tr><td>sshd_config</td><td>是使用加密算法的服务器端的密钥对公共秘钥</td></tr><tr><td>ssh_host_ecdsa_key</td><td>是使用加密算法的服务器端的密钥对私有秘钥</td></tr><tr><td>ssh_host_ecdsa_key.pub</td><td>是使用加密算法的服务器端的密钥对的公共秘钥</td></tr><tr><td>ssh_host_ed25519_key</td><td>是使用加密算法的服务器端的密钥对私有秘钥</td></tr><tr><td>ssh_host_ed25519_key.pub</td><td>是使用加密算法的服务器端的密钥对的公共秘钥</td></tr><tr><td>ssh_host_rsa_key</td><td>是使用加密算法的服务器端的密钥对私有秘钥</td></tr><tr><td>ssh_host_rsa_key.pub</td><td>是使用加密算法的服务器端的密钥对的公共秘钥</td></tr></tbody></table><blockquote style="border-left: 5px solid #6CA2F9; background-color: #ECF3FE; padding: 10px;"><div style="color: #24687D; font-weight: bold;height: 20px;height:25px;">🔵 注意：</div>     <p style=" text-indent: 2em;"><code>/etc/ssh/ssh_config</code> 这里面记录了服务器端的公共秘钥文件，就在Hostkey这一部分。</p>    <p style=" text-indent: 2em;"><code>SyslogFacility AUTHPRIV</code>这与日志有关，后面指定了记录到安全日志的信息就是 /vr/log/secure 这个文件。</p>    <p style=" text-indent: 2em;"><code>PermitRootLogin yes</code> 允许root用户能够登陆。通过root登陆并不是很安全。</p></blockquote><p>除了修改配置文件，重启程序，还要考虑  <strong><code>selinux</code><strong>、</strong><code>防火墙的设置</code></strong> 。</p><p><strong>DNS反向解析：</strong>是指把 IP地址 解析成 主机名、域名， ssh用这个特性可以进行安全检查，但是如果ssh服务部署在内网，你的DNS没有做反向记录，当客户端来连接的时候，ssh去查服务器尝试进行反向解析，而DNS又没有记录，所以会超时，这就会等一段时间，所以会感觉卡一下，所以对与内网是 ssh 服务器来说，如果你的DNS没有设置查询的区域、记录，那么就可以设置成 no。</p><h2 id="➡️防火墙配置"><a href="#➡️防火墙配置" class="headerlink" title="➡️防火墙配置"></a>➡️防火墙配置</h2><h3 id="🟦背景知识：firewalld-的区域"><a href="#🟦背景知识：firewalld-的区域" class="headerlink" title="🟦背景知识：firewalld 的区域"></a>🟦背景知识：firewalld 的区域</h3><p>在CentOS8中，默认使用的是 firewalld 进行防火墙的管理。</p><p>firewalld 引入了一个区域与服务的概念，这样使得管理员管理起来更高效，区域也就是Zone 这是针对特定的应用或者是场景，可能具有的各种信任级别的一些与预设定的规则集。</p><p><img src="/images/remote-administration/sshfirewalld.png"></p><p>Zone最大的好处就是切换方便，可以在不同的环境下把Zone应用到网卡，源主机。比如：出差去连接公共的WiFi最好就是使用公共网络，这样配置的比较严格那么就会比较安全，而在家中连接的是自己的WiFi那么就可以获得比较宽松的规则。</p><h3 id="🟦原有默认的规则"><a href="#🟦原有默认的规则" class="headerlink" title="🟦原有默认的规则"></a>🟦原有默认的规则</h3><p><img src="/images/remote-administration/sshf2.png"></p><p>第一行：当前的活动区域只有public，public与机器上一个叫 ens160 的网卡做关联。</p><p>第二行：没有去指定Zone的名称，那么会采用默认的public区域。</p><br><p>需求：假设一个管理员他的IP地址是192.168.1.49，为了安全想使用防火墙来限制一下，要求只允许 192.168.1.49 来进行通过ssh服务端来进行管理，这个需求在防火墙配置中有很多的方法，比如说把这个ip地址添加到，trusted这个区域里面，然后在这个区域中允许ssh服务器的入站，然后把原来public的ssh服务给删除掉。</p><p>第三行：没有和ip做捆绑，也没有服务，这就需要调整。</p><br><h3 id="🟦只允许管理员在特定主机上访问SSH服务器"><a href="#🟦只允许管理员在特定主机上访问SSH服务器" class="headerlink" title="🟦只允许管理员在特定主机上访问SSH服务器"></a>🟦只允许管理员在特定主机上访问SSH服务器</h3><p><img src="/images/remote-administration/sshf3.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># firewall-cmd --permanent --add-source=192.168.1.19 --zone=trusted</span><br><span class="line"># firewall-cmd --permanent --add-serice=ssh --zone=trusted</span><br><span class="line"></span><br><span class="line"># firewall-cmd --permanent --remove-service=ssh --zone=public</span><br><span class="line"># firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>第一行：通过 <code>--add-source</code> 添加到 <code>trusted</code> 中，也就是把ip和信任区域做关联。</p><p>第二行：添加ssh服务。</p><p>第三行：把原来的服务删除掉。</p><p>第四行：重新加载。</p><p><strong>修改规则之后：</strong></p><p><img src="/images/remote-administration/sshf4.png"></p><br><h2 id="➡️监听端口修改"><a href="#➡️监听端口修改" class="headerlink" title="➡️监听端口修改"></a>➡️监听端口修改</h2><p>单位的管理员根据单位的安全策略，需要去修改ssh服务器的配置，把默认监听的22端口，修改成222。</p><p>通过修改端口号来隐藏服务，这种做法对于新版本的扫描器来讲基本上用处不大，因为新版本的扫描器扫描的工具都很强大。</p><p>操作并不复杂，但是为了完成这个目标，需要修改除了ssh服务器的配置以外，还要修改selinux的策略和防火墙的配置。</p><p>selinux在默认的情况下会阻止sshd这个进程监听除了22以外的其他的非标准端口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># yum -y install policycoreutils-python-utils</span><br><span class="line"></span><br><span class="line"># semanage port -a -t ssh_port_t -p tcp 2222</span><br><span class="line"># semanage port -l | grep ssh</span><br><span class="line"></span><br><span class="line"># vi /etc/ssh/sshd_config</span><br><span class="line">修改为: Port 22 为 Port 2222</span><br><span class="line"></span><br><span class="line"># firewalld-cmd --permanent --add-port 2222/tcp</span><br><span class="line"># firewalld-cmd --reload</span><br><span class="line"># systemctl restart sshd</span><br></pre></td></tr></table></figure><blockquote style="border-left: 5px solid #f00; background-color: #ffe5e5; padding: 10px;"><div style="color: #f00; font-weight: bold;height: 20px;height:25px;">🔴 警告：</div>     <p style=" text-indent: 2em;">直接修改 端口号而不做其他的工作要保存。</p></blockquote><blockquote style="border-left: 5px solid #f0ab00; background-color: #fdf7e7; padding: 10px;"><div style="color: #7d643f; font-weight: bold;height: 20px;height:25px;">🟡 重要：</div>     <p style=" text-indent: 2em;">一些深入的检查，可以查看 <code>端口号</code></p>    <p style=" text-indent: 2em;"><code>/var/log/messages</code> 系统日志</p>    <p style=" text-indent: 2em;"><code>/var/log/secure</code> 系统安全日志</p>    <p style=" text-indent: 2em;"><code>/var/log/audit/audit.log</code> 审计日志，看这种 type=AVC 这叫做访问向量缓存，这是selinux的日志。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;远程访问会用到 &lt;code&gt;ssh&lt;/code&gt; 、&lt;code&gt;telnet&lt;/code&gt; ，对于 telent 来说传输的数据是不加密的，密码是通过纯文本的形式来传递的，可以使用包获取工具来进行抓包解析。&lt;/p&gt;
&lt;br&gt;

&lt;h1 id=&quot;⬆️Telnet&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="Linux服务配置" scheme="http://example.com/categories/Linux%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE/"/>
    
    
    <category term="ssh" scheme="http://example.com/tags/ssh/"/>
    
    <category term="telnet" scheme="http://example.com/tags/telnet/"/>
    
  </entry>
  
  <entry>
    <title>subnetting</title>
    <link href="http://example.com/2024/01/03/subnetting/"/>
    <id>http://example.com/2024/01/03/subnetting/</id>
    <published>2024-01-03T10:33:26.000Z</published>
    <updated>2024-01-03T12:38:28.638Z</updated>
    
    <content type="html"><![CDATA[<h1>1.划分子网</h1><p>划分子网用于缓解网络号不足的情况，网络允许划分更小的网络，这样的网络称为 <code>子网</code> ，从实际上就是从主机部分借位来表示子网。</p><ul><li><p><strong>子网号</strong></p><p>主机号的前几位</p></li><li><p><strong>主机位数</strong></p><p>主机位数=32-现有子网掩码1的个数</p></li></ul><br><h2 id="1-1-求子网地址和子网号：">1.1 求子网地址和子网号：</h2><p><strong>网络号</strong> 也称 <strong>网络地址</strong></p><p>子网地址：网络号（照抄）+ 子网号（照抄）+ 主机号（全部是0）</p><p>广播地址：网络号（照抄）+ 子网号（照抄）+ 主机号（全部是1）</p><p>子网掩码：网络号（全部为1）+ 子网号（全部为1）+ 主机号（全部是1）</p><br><h3 id="1-1-2-示列">1.1.2 示列:</h3><p>IP地址为 <code>192.168.1.163</code>，子网掩码 <code>255.255.255.224</code> 。</p><p>网络号是 <code>192.168.1</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">相关地址: 11000000  10101000  00000001  10100011   192.168.1.163</span><br><span class="line">子网掩码: 11111111  11111111  11111111  11100000   255.255.255.224</span><br><span class="line">子网地址: 11000000  10101000  00000001  10100000   192.168.1.160</span><br></pre></td></tr></table></figure><p>这里的子网号是5，子网位数本示列是3，所以10100000，取三位是5。</p><p>子网号（数字）：把IP地址和子网掩码最后一组进行 <code>与运算</code> ，在结果上从左往右区 n 位，再转十进制，不过在算 <strong>子网地址</strong> 的时候子网号是八位的二进制转十进制。</p><h2 id="1-2-其他">1.2 其他</h2><p>子网个数 = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span> （n 表示子网位数）</p><p>主机数量 = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>m</mi></msup><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2^{m}-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> （m 表示主机位数）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1.划分子网&lt;/h1&gt;
&lt;p&gt;划分子网用于缓解网络号不足的情况，网络允许划分更小的网络，这样的网络称为 &lt;code&gt;子网&lt;/code&gt; ，从实际上就是从主机部分借位来表示子网。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;子网号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主机</summary>
      
    
    
    
    <category term="网络层" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
    
    <category term="划分子网" scheme="http://example.com/tags/%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Internet-Protocol-Address</title>
    <link href="http://example.com/2024/01/03/Internet-Protocol-Address/"/>
    <id>http://example.com/2024/01/03/Internet-Protocol-Address/</id>
    <published>2024-01-03T03:49:42.000Z</published>
    <updated>2024-01-04T03:40:48.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h1><p><strong>IP地址的组成：网络地址+主机地址</strong></p><p>在 Internet 网络中，IP地址有两种表现形式：IP地址 和 域名</p><p><strong>点分十进制</strong>：在 ipv4中 IP地址分为4组，每组8个二进制，每组使用 <code>.</code> 来分隔。</p><p><br></p><h1 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h1><p><strong>特殊的IP地址</strong></p><div class="table-container"><table><thead><tr><th>表现形式</th><th>用途</th></tr></thead><tbody><tr><td>以 0 开头</td><td>服务器监听</td></tr><tr><td>以 127 开头</td><td>本机测试</td></tr><tr><td>主机部分全0</td><td>网络地址</td></tr><tr><td>主机部分全1</td><td>广播地址</td></tr></tbody></table></div><ul><li><p><strong>A类地址：</strong></p><p>IP地址特征最高位是0，第一节字节是网络地址，有效地址的范围是 1~126 。</p></li><li><p><strong>B类地址：</strong></p><p>最高位前两10，前两个字节是网络地址，地址范围 128.0.0.1 ~ 192.255.255.254</p></li><li><p><strong>C类地址：</strong></p><p>最高位前三位是110，前三个字节是网络地址，地址范围 192.0.0.1 ~ 223.255.255.254</p></li><li><p><strong>D类地址：</strong></p><p>地址范围是 224.0.0.0 ~ 239.255.255.255 用于多路广播，叫做多播地址</p></li><li><p><strong>E类地址：</strong></p><p>地址范围是 240.0.0.0 ~ 255.255.255.255 保留拓展地址</p></li></ul><p><br></p><h1 id="保留的IP地址（私有IP地址）"><a href="#保留的IP地址（私有IP地址）" class="headerlink" title="保留的IP地址（私有IP地址）"></a>保留的IP地址（私有IP地址）</h1><p>这些地址不需要申请，可以直接使用，这些地址只能在局域网内部使用，不能出现在 Internet 上。</p><div class="table-container"><table><thead><tr><th>网络类型</th><th>地址范围</th><th>默认子网掩码</th><th>特征</th></tr></thead><tbody><tr><td>A</td><td>10.0.0.1 ~ 10.255.255.254</td><td>255.0.0.0</td><td>以 10 来头</td></tr><tr><td>B</td><td>172.16.0.1 ~ 172.31.255.255.254</td><td>255.255.0.0</td><td>以 172.16 ~172.31 开头</td></tr><tr><td>C</td><td>192.168.0.1 ~ 192.168.255.254</td><td>255.255.255.0</td><td>以 192.168 开头</td></tr></tbody></table></div><p><br></p><h1 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h1><p>由128位二进制构成，采用 <strong>冒号十六进制</strong> 表示，并分成了8组，每组4位的十六进制。</p><p>理论上说 IPV6 的 IP 地址个数是 IPV4 的 IP 地址个数的 $2^{96}$ 倍。</p><script type="math/tex; mode=display">\frac {2^{128}}{2^{32}}=2^{96}</script><p><br></p><h2 id="使用冒分十六进制"><a href="#使用冒分十六进制" class="headerlink" title="使用冒分十六进制"></a>使用冒分十六进制</h2><ul><li><p><strong>零点压缩法：</strong></p><p>把连续的1组或多组0可以省略</p><p>如：<code>EF00:0000:0000:0000:0002:0000:0001:0003</code></p><p>压缩为：<code>EF00::0002:0000:0001:0003</code></p></li><li><p><strong>可省略每组前面的零</strong></p><p>如：<code>EF00:0000:0000:0000:0002:0000:0001:0003</code></p><p>压缩为：<code>EF00:0:0:0002:0:1:3</code></p></li><li><p><strong>也可以上面的合起来一起用</strong></p><p>如：<code>EF00:0000:0000:0000:0002:0000:0001:0003</code></p><p>压缩为：<code>EF00::2:0:1:3</code></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IP地址&quot;&gt;&lt;a href=&quot;#IP地址&quot; class=&quot;headerlink&quot; title=&quot;IP地址&quot;&gt;&lt;/a&gt;IP地址&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;IP地址的组成：网络地址+主机地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 Internet 网络中，IP地址有</summary>
      
    
    
    
    <category term="网络层" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
    
    <category term="IP地址" scheme="http://example.com/tags/IP%E5%9C%B0%E5%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>new2024</title>
    <link href="http://example.com/2024/01/01/new2024/"/>
    <id>http://example.com/2024/01/01/new2024/</id>
    <published>2024-01-01T05:57:37.000Z</published>
    <updated>2024-01-05T11:35:16.899Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2024-1-1"><a href="#2024-1-1" class="headerlink" title="2024&#x2F;1&#x2F;1"></a>2024&#x2F;1&#x2F;1</h1><p><img src="/images/202411.jpeg" alt="default"></p><center>守株待兔，固不可取。</center><center>叶公好龙，亦非所得。</center><center>临渊羡鱼，不如退而结网。</center><center>亡羊补牢，何如未雨绸缪。</center><p align="right">图片出处：赵芾江山万里图卷</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2024-1-1&quot;&gt;&lt;a href=&quot;#2024-1-1&quot; class=&quot;headerlink&quot; title=&quot;2024&amp;#x2F;1&amp;#x2F;1&quot;&gt;&lt;/a&gt;2024&amp;#x2F;1&amp;#x2F;1&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/202411.j</summary>
      
    
    
    
    <category term="log" scheme="http://example.com/categories/log/"/>
    
    
    <category term="life" scheme="http://example.com/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>newbin</title>
    <link href="http://example.com/2023/12/31/newbin/"/>
    <id>http://example.com/2023/12/31/newbin/</id>
    <published>2023-12-31T04:42:11.000Z</published>
    <updated>2024-01-01T07:36:24.601Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2023/12/31/newbin/default.jpeg" alt></p><p>I hope the Pacific is as blue as it has been in my dreams.<br>I hope.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2023/12/31/newbin/default.jpeg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;I hope the Pacific is as blue as it has been in my dreams.&lt;br&gt;
I hope.&lt;/p&gt;
</summary>
      
    
    
    
    <category term="log" scheme="http://example.com/categories/log/"/>
    
    
    <category term="life" scheme="http://example.com/tags/life/"/>
    
  </entry>
  
</feed>
